---
title: "理解 Quntile Normalization"
date: 2022-08-25T05:10:13Z
tags: 
---
理解 Quntile Normalization by 果子学生信 
------
<div><p>每一次技术重复的时候，都会有误差，芯片的原始数据是由仪器读取的，不同的读取时间，或者扫描仪光线的强弱都会导致同一类型的样本出现误差，</p><p>比如，3vs3的实验设计中，3个样本居然重复性不好，而理论上他们应该是一样的。</p><p>这时候就出现了Quntile Normalization方法来校正这个误差。</p><p>我们创造一个矩阵，行是不同的基因，列是不同的样本, 同时我们用boxplot看一下他的分布</p><pre><ol><li><p><code><span>quntile_test </span><span>&lt;-</span><span> matrix</span><span>(</span><span>c</span><span>(</span><span>2</span><span>,</span><span>5</span><span>,</span><span>4</span><span>,</span><span>3</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>14</span><span>,</span><span>8</span><span>,</span><span>8</span><span>,</span><span>9</span><span>,</span><span>4</span><span>,</span><span>4</span><span>,</span><span>6</span><span>,</span><span>5</span><span>,</span><span>3</span><span>,</span><span>5</span><span>,</span><span>7</span><span>,</span><span>9</span><span>,</span><span>8</span><span>,</span><span>5</span><span>),</span><span>ncol</span><span>=</span><span>4</span><span>,</span><span>byrow </span><span>=</span><span> F</span><span>)</span></code></p></li><li><p><code><span>boxplot</span><span>(</span><span>quntile_test</span><span>)</span></code></p></li></ol></pre><p>大概是这个样子的： <img data-ratio="0.5112960760998811" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTL2JRomXO8nNtge3WHMYuPxN93ribF8colPicIndeBooZ85mTtiaJpM16HA/640?wx_fmt=png" data-type="png" data-w="841" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTL2JRomXO8nNtge3WHMYuPxN93ribF8colPicIndeBooZ85mTtiaJpM16HA/640?wx_fmt=png"></p><p>然后我们对他进行Quntile Normalization，然后就变成这个样子了<img data-ratio="0.5172413793103449" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLKZDo1snRUgAERldGuVbJsQ9DVNuqia93foO4Ly6sEv0Ecja56ia9pDYQ/640?wx_fmt=png" data-type="png" data-w="841" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLKZDo1snRUgAERldGuVbJsQ9DVNuqia93foO4Ly6sEv0Ecja56ia9pDYQ/640?wx_fmt=png"></p><p>确实效果不错,我们来看一下这个原理 <img data-ratio="0.4339513325608343" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLc7W0ACvKAbdaLYQRQTHicS4yEhRpYKxlcpNWrYH9rgb6HOicBemicGrcA/640?wx_fmt=png" data-type="png" data-w="1726" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLc7W0ACvKAbdaLYQRQTHicS4yEhRpYKxlcpNWrYH9rgb6HOicBemicGrcA/640?wx_fmt=png"></p><p>首先每一行是不同的基因，用不同的颜色表示，</p><p>把每一列的数据从小到大排列，这时候基因的顺序是乱的</p><p>把排列后的数据每一行求一个平均值，这时候基因的顺序还是乱的</p><p>最后，把基因的顺序恢复到原来的样子。</p><p>讲起来很复杂，但是做起来却很简单，在R语言中我们用R包preprocessCore来实现：</p><pre><ol><li><p><code><span>library</span><span>(</span><span>BiocInstaller</span><span>)</span></code></p></li><li><p><code><span>biocLite</span><span>(</span><span>"preprocessCore"</span><span>)</span></code></p></li><li><p><code><span>library</span><span>(</span><span>preprocessCore</span><span>)</span></code></p></li><li><p><code><span>new</span><span> </span><span>&lt;-</span><span> normalize</span><span>.</span><span>quantiles</span><span>(</span><span>quntile_test</span><span>)</span></code></p></li></ol></pre><p>做个图出来看一下，看达到效果没有 <img data-ratio="0.5108173076923077" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLdGg595pMbOA2aZCpbcPgf89ibsnia3gcsibZvTlNFvibEyH9gp4zkBaa5w/640?wx_fmt=png" data-type="png" data-w="832" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLdGg595pMbOA2aZCpbcPgf89ibsnia3gcsibZvTlNFvibEyH9gp4zkBaa5w/640?wx_fmt=png"></p><p>最后一个样本出现了问题。没有办法解决，但是原理已经清楚了，我们可以自己写函数来搞定</p><p>1.首先把数据搞出来</p><pre><ol><li><p><code><span>df </span><span>&lt;-</span><span> data</span><span>.</span><span>frame</span><span>(</span><span>c</span><span>(</span><span>2</span><span>,</span><span>5</span><span>,</span><span>4</span><span>,</span><span>3</span><span>,</span><span>3</span><span>),</span><span>c</span><span>(</span><span>4</span><span>,</span><span>14</span><span>,</span><span>8</span><span>,</span><span>8</span><span>,</span><span>9</span><span>),</span><span>c</span><span>(</span><span>4</span><span>,</span><span>4</span><span>,</span><span>6</span><span>,</span><span>5</span><span>,</span><span>3</span><span>),</span><span>c</span><span>(</span><span>5</span><span>,</span><span>7</span><span>,</span><span>9</span><span>,</span><span>8</span><span>,</span><span>5</span><span>))</span></code></p></li><li><p><code><span>colnames</span><span>(</span><span>df</span><span>)</span><span> </span><span>&lt;-</span><span> paste0</span><span>(</span><span>"Sample"</span><span>,</span><span>seq</span><span>(</span><span>1</span><span>,</span><span>4</span><span>))</span></code></p></li><li><p><code><span>rownames</span><span>(</span><span>df</span><span>)</span><span> </span><span>&lt;-</span><span> paste0</span><span>(</span><span>"Gene"</span><span>,</span><span>seq</span><span>(</span><span>1</span><span>,</span><span>5</span><span>))</span></code></p></li><li><p><code><span>df</span></code></p></li></ol></pre><p><img data-ratio="0.4020408163265306" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLdXDDCwv9vjjwl6n0Yomhia6Zv7k6zOcvwPJ1sf43N2dCGBDAkAdTsWA/640?wx_fmt=png" data-type="png" data-w="490" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLdXDDCwv9vjjwl6n0Yomhia6Zv7k6zOcvwPJ1sf43N2dCGBDAkAdTsWA/640?wx_fmt=png">数据没有问题</p><p>2.给每一列的数据排序，返回排序的秩</p><pre><ol><li><p><code><span>df_rank </span><span>&lt;-</span><span> apply</span><span>(</span><span>df</span><span>,</span><span>2</span><span>,</span><span>rank</span><span>,</span><span>ties</span><span>.</span><span>method</span><span>=</span><span>"min"</span><span>)</span></code></p></li><li><p><code><span>df_rank</span></code></p></li></ol></pre><p><img data-ratio="0.3702213279678068" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLYwibDMqjWibqVYK4FLeU1Z8gubic14rgyfzPia60ic2Io1pOZ5MzB1e5vhQ/640?wx_fmt=png" data-type="png" data-w="497" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLYwibDMqjWibqVYK4FLeU1Z8gubic14rgyfzPia60ic2Io1pOZ5MzB1e5vhQ/640?wx_fmt=png"></p><p>3.把每一列的数据按照从小到大排序</p><pre><ol><li><p><code><span>df_sorted </span><span>&lt;-</span><span> data</span><span>.</span><span>frame</span><span>(</span><span>apply</span><span>(</span><span>df</span><span>,</span><span> </span><span>2</span><span>,</span><span> sort</span><span>))</span></code></p></li><li><p><code><span>df_sorted</span></code></p></li></ol></pre><p><img data-ratio="0.40315315315315314" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTL1E7duw0CqeratUDKdIelhWzX52d2CFdMkMeOh8b02kSPLjhWQO4EbQ/640?wx_fmt=png" data-type="png" data-w="444" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTL1E7duw0CqeratUDKdIelhWzX52d2CFdMkMeOh8b02kSPLjhWQO4EbQ/640?wx_fmt=png"></p><p>4.把每一行的平均值求出来</p><pre><ol><li><p><code><span>df_mean </span><span>&lt;-</span><span> apply</span><span>(</span><span>df_sorted</span><span>,</span><span> </span><span>1</span><span>,</span><span> mean</span><span>)</span></code></p></li><li><p><code><span>df_mean</span></code></p></li></ol></pre><pre><ol><li><p><code><span>[</span><span>1</span><span>]</span><span> </span><span>3.5</span><span> </span><span>5.0</span><span> </span><span>5.5</span><span> </span><span>6.5</span><span> </span><span>8.5</span></code></p></li></ol></pre><p>5.最后按照之前排好的顺序，把这个平均值对应起来，代替原来的值</p><p>写一个函数，输入一开始排序的秩，返回出对应的平均值</p><pre><ol><li><p><code><span>index_to_mean </span><span>&lt;-</span><span> </span><span>function</span><span>(</span><span>my_index</span><span>,</span><span> my_mean</span><span>){</span></code></p></li><li><p><code><span>  </span><span>return</span><span>(</span><span>my_mean</span><span>[</span><span>my_index</span><span>])</span></code></p></li><li><p><code><span>}</span></code></p></li><li><p><code><span>df_final </span><span>&lt;-</span><span> apply</span><span>(</span><span>df_rank</span><span>,</span><span> </span><span>2</span><span>,</span><span> index_to_mean</span><span>,</span><span> my_mean</span><span>=</span><span>df_mean</span><span>)</span></code></p></li><li><p><code><span>df_final</span></code></p></li><li><p><code><span>boxplot</span><span>(</span><span>df_final</span><span>)</span></code></p></li></ol></pre><p>运行成功了，但是问题依然存在 <img data-ratio="0.5894308943089431" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLVcbpc0CpfVv7r8ADhic6wjDn4dzJ0sqOoRmFNA9yxxiaq23TsQLucKHg/640?wx_fmt=png" data-type="png" data-w="738" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLVcbpc0CpfVv7r8ADhic6wjDn4dzJ0sqOoRmFNA9yxxiaq23TsQLucKHg/640?wx_fmt=png"></p><p>追查问题后发现，问题出现在第一步rank，那里选择了ties.method="min"，导致如果一个序列中有两个一个，他们的秩就一样 <img data-ratio="0.35671342685370744" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTL3thuiamYicPWfRiaa5CjdB375vQXZ3U5zyicomepgibKu07EXGz90mQlW4w/640?wx_fmt=png" data-type="png" data-w="499" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTL3thuiamYicPWfRiaa5CjdB375vQXZ3U5zyicomepgibKu07EXGz90mQlW4w/640?wx_fmt=png"></p><p>把他改成ties.method="first"后就好了 <img data-ratio="0.3532934131736527" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLUib2eEPZvHCyn6tkH7sD2vwGUTSowN7aZSXMvWD5XBU4csVsibbv5HJQ/640?wx_fmt=png" data-type="png" data-w="501" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLUib2eEPZvHCyn6tkH7sD2vwGUTSowN7aZSXMvWD5XBU4csVsibbv5HJQ/640?wx_fmt=png"></p><p>考虑到这个需求很常见，以及现有的工具没办法满足要求，我们把他写成一个函数，自己用</p><pre><ol><li><p><code><span>quantile_normalisation </span><span>&lt;-</span><span> </span><span>function</span><span>(</span><span>df</span><span>){</span></code></p></li><li><p><code><span>  df_rank </span><span>&lt;-</span><span> apply</span><span>(</span><span>df</span><span>,</span><span>2</span><span>,</span><span>rank</span><span>,</span><span>ties</span><span>.</span><span>method</span><span>=</span><span>"first"</span><span>)</span></code></p></li><li><p><code><span>  df_sorted </span><span>&lt;-</span><span> data</span><span>.</span><span>frame</span><span>(</span><span>apply</span><span>(</span><span>df</span><span>,</span><span> </span><span>2</span><span>,</span><span> sort</span><span>))</span></code></p></li><li><p><code><span>  df_mean </span><span>&lt;-</span><span> apply</span><span>(</span><span>df_sorted</span><span>,</span><span> </span><span>1</span><span>,</span><span> mean</span><span>)</span></code></p></li><li><p><code></code></p></li><li><p><code><span>  index_to_mean </span><span>&lt;-</span><span> </span><span>function</span><span>(</span><span>my_index</span><span>,</span><span> my_mean</span><span>){</span></code></p></li><li><p><code><span>    </span><span>return</span><span>(</span><span>my_mean</span><span>[</span><span>my_index</span><span>])</span></code></p></li><li><p><code><span>  </span><span>}</span></code></p></li><li><p><code></code></p></li><li><p><code><span>  df_final </span><span>&lt;-</span><span> apply</span><span>(</span><span>df_rank</span><span>,</span><span> </span><span>2</span><span>,</span><span> index_to_mean</span><span>,</span><span> my_mean</span><span>=</span><span>df_mean</span><span>)</span></code></p></li><li><p><code><span>  rownames</span><span>(</span><span>df_final</span><span>)</span><span> </span><span>&lt;-</span><span> rownames</span><span>(</span><span>df</span><span>)</span></code></p></li><li><p><code><span>  </span><span>return</span><span>(</span><span>df_final</span><span>)</span></code></p></li><li><p><code><span>}</span></code></p></li></ol></pre><p>我们试一下效果</p><pre><ol><li><p><code><span>new</span><span> </span><span>&lt;-</span><span> quantile_normalisation</span><span>(</span><span>df</span><span>)</span></code></p></li><li><p><code><span>boxplot</span><span>(</span><span>new</span><span>)</span></code></p></li></ol></pre><p>确实很不错！ <img data-ratio="0.5853658536585366" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLsjeNl8eXkHegDOpZ48NtlyvdyictXHf6obX3RIRIJdZ8JWUWF5232JA/640?wx_fmt=png" data-type="png" data-w="738" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTLsjeNl8eXkHegDOpZ48NtlyvdyictXHf6obX3RIRIJdZ8JWUWF5232JA/640?wx_fmt=png"></p><p>对于这个过程，如果还不理解的话，statquest上还有个视频 https://goo.gl/6APsUr</p><p>还有一个重要的问题，做Quntile Normalization的假设是差异来自于技术重复，但是如果这个差异来自于生物背景呢，</p><p>比如，样品来自于不同的组织，他们的基因本身就很不一样，这时候怎么办？</p><p>要是我，我就是先分类，再分别做Quntile Normalization，</p><p>而判定是否来自于不同的样本，有一个R可以做 R-package quantro</p><p>在这个R包的文章中有一个图是这样的 <img data-ratio="0.6192250372578242" data-src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTL84pLUykmuZkFnEEnIjQZMLLbibQUbeT7MAByxMCMMDibUbOmd24UrRkw/640?wx_fmt=png" data-type="png" data-w="1342" src="https://mmbiz.qpic.cn/mmbiz_png/NDy5aEnReX2dicfwrRA7ooI6IlaBXpiaTL84pLUykmuZkFnEEnIjQZMLLbibQUbeT7MAByxMCMMDibUbOmd24UrRkw/640?wx_fmt=png"></p><p>最左边的图说，如果这个样本见没有技术上的差异，可以做，也可以不做</p><p>中间的图，如果样本间有技术差异，那么一定要做</p><p>第三章图，如果样本有重复，也有不同来源，要判断！判断就用R-package quantro</p><p>参考资料： https://goo.gl/FYhwpG</p><p>https://goo.gl/kLP2fB</p><p>https://goo.gl/L6Q1qJ(健明的博客)</p><p><br></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/YL3UeWzA6Ysi5b3nnTxiww",target="_blank" rel="noopener noreferrer">原文链接</a>
