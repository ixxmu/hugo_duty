---
title: "逆向工程，如何从移动端应用提取本地 AI 模型，附成功提取微软Seeing AI 模型"
date: 2025-01-06T02:07:16Z
draft: ["false"]
tags: [
  "fetched",
  "老码小张"
]
categories: ["Duty"]
---
逆向工程，如何从移动端应用提取本地 AI 模型，附成功提取微软Seeing AI 模型 by 老码小张
------
<div><p><span leaf=""> </span></p><p><span leaf="">最近我看到了一个有趣的话题：如何从移动应用中提取 AI 模型。虽然听起来有些“黑客范儿”，但这其实是一个非常技术性的问题——它涉及移动端的 AI 模型存储方式、加密保护手段以及逆向工程方法的实际应用。</span></p><figure><span leaf=""><img data-imgfileid="100004741" data-ratio="0.3685185185185185" data-type="png" data-w="1080" title="null" data-src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ou0llia9ghWMMdD0PicfstWQ1jhNul0kcQ6aK5MhQic64H3u7dFbRIuxBew/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ou0llia9ghWMMdD0PicfstWQ1jhNul0kcQ6aK5MhQic64H3u7dFbRIuxBew/640?wx_fmt=png&amp;from=appmsg"></span><figcaption></figcaption></figure><hr><h4><strong><span leaf="">为什么提取 AI 模型？</span></strong></h4><p><span leaf="">移动端 AI 模型的应用越来越广泛，比如实时物体识别、拍照美化、语音助手等。而这些模型的运行方式分为两种：</span><strong><span leaf="">云端推理</span></strong><span leaf="">和</span><strong><span leaf="">本地推理</span></strong><span leaf="">。</span></p><p><span leaf="">本地推理有个显著优势——离线也能用，且响应速度快。于是，很多应用选择把 AI 模型直接打包在安装包（如 APK）里。对于技术研究者来说，这些模型就变成了“可探究的目标”。</span></p><p><span leaf="">当然，正如你所想，这种提取行为可能涉及法律问题，后面我们会简单聊聊。</span></p><hr><h4><strong><span leaf="">目标应用：Seeing AI</span></strong></h4><figure><span leaf=""><img data-imgfileid="100004744" data-ratio="0.5100401606425703" data-type="png" data-w="996" title="null" data-src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ouOAbPXgKBG9zB9mo1X5NZKRvjxttj11APRLib5eewd4rzicrNbmTHibA3A/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ouOAbPXgKBG9zB9mo1X5NZKRvjxttj11APRLib5eewd4rzicrNbmTHibA3A/640?wx_fmt=png&amp;from=appmsg"></span><figcaption></figcaption></figure><p><span leaf="">我们以微软的 Seeing AI 应用为例，这是一个为视觉障碍者设计的辅助工具。它的亮点功能是</span><strong><span leaf="">货币识别</span></strong><span leaf="">，支持 17 种货币和 225 张不同的纸币。看起来很酷，对吧？但这也意味着它一定有一个强大的 AI 模型在背后运行。</span></p><p><span leaf="">一个朋友提到对这部分功能感兴趣，于是我决定从技术角度来一探究竟。</span></p><hr><h4><strong><span leaf="">第一步：解包 APK</span></strong></h4><p><span leaf="">Android 应用的安装包是一个叫 APK（Android Package Kit）的文件，本质上是一个压缩包。里面包含了应用的所有资源：代码、图片、字体以及我们的目标——AI 模型文件。</span></p><figure><span leaf=""><img data-imgfileid="100004742" data-ratio="0.3148148148148148" data-type="png" data-w="1080" title="null" data-src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ouuErkcvxC9VZehYAEBK6fgP0sdvUic8XdWmHLeNj8xlqLMibnPRvOfibeQ/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ouuErkcvxC9VZehYAEBK6fgP0sdvUic8XdWmHLeNj8xlqLMibnPRvOfibeQ/640?wx_fmt=png&amp;from=appmsg"></span><figcaption></figcaption></figure><p><span leaf="">解包 APK 最常用的工具是 </span><strong><span><span leaf="">apktool</span><sup><span leaf="">[1]</span></sup></span></strong><span leaf="">，它可以把 APK 解包成一个文件夹结构，便于我们查看每个文件的用途。</span></p><pre><span hidden=""><svg xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" width="45px" height="13px" viewbox="0 0 450 130"><ellipse cx="50" cy="65" rx="50" ry="52" stroke="rgb(220,60,54)" stroke-width="2" fill="rgb(237,108,96)"></ellipse><ellipse cx="225" cy="65" rx="50" ry="52" stroke="rgb(218,151,33)" stroke-width="2" fill="rgb(247,193,81)"></ellipse><ellipse cx="400" cy="65" rx="50" ry="52" stroke="rgb(27,161,37)" stroke-width="2" fill="rgb(100,200,86)"></ellipse></svg></span><code><span leaf="">apktool d seeingai.apk -o seeingai_unpacked</span></code></pre><p><span leaf="">解包后，找到 </span><code><span leaf="">assets</span></code><span leaf=""> 文件夹，这里通常存放模型、配置文件等。果然，我发现了一个叫 </span><code><span leaf="">currency</span></code><span leaf=""> 的大文件，大小超过 16 MB，旁边还有一个 </span><code><span leaf="">currency-labels.txt</span></code><span leaf="">。看起来，模型目标近在眼前了！</span></p><hr><h4><strong><span leaf="">第二步：加密模型文件</span></strong></h4><p><span leaf="">但是，直接打开 </span><code><span leaf="">currency</span></code><span leaf=""> 文件却让人沮丧——文件内容被加密了。常见分析工具如 </span><code><span leaf="">file</span></code><span leaf=""> 和 </span><code><span leaf="">binwalk</span></code><span leaf=""> 都无法识别文件结构，甚至文件的熵值是 1（完全随机化），说明这文件经过了严格的加密处理。</span></p><p><span leaf="">这里需要用到逆向工程技术，具体来说就是要搞清楚：</span><strong><span leaf="">应用是如何解密这个模型文件的？</span></strong></p><hr><h4><strong><span leaf="">第三步：逆向解密逻辑</span></strong></h4><p><span leaf="">接下来就是经典的“逆向解密”操作了。开发者为了保护模型，常用一些非常规的加密手段，比如：</span></p><ul><li><section><span leaf="">• 倒着读取文件内容；</span></section></li><li><section><span leaf="">• 对字节做各种位移、模运算；</span></section></li><li><section><span leaf="">• 加密密钥可能跟日期、设备 ID 有关。</span></section></li></ul><p><span leaf="">要搞清楚这些操作，通常需要分析应用的代码。通过解包后得到的 Smali 文件（Android 的字节码格式）或者用动态分析工具直接调试运行中的应用。</span></p><p><span leaf="">不过，这样的方式又慢又复杂。我更喜欢一个“直截了当”的办法：观察文件最终是如何加载到推理引擎中的。</span></p><hr><h4><strong><span leaf="">第四步：截获 TensorFlow Lite 加载模型</span></strong></h4><p><span leaf="">大多数移动端 AI 应用都使用 TensorFlow Lite（以下简称 TFLite）来运行模型，而微软的 Seeing AI 也不例外。在 </span><code><span leaf="">apktool</span></code><span leaf=""> 的输出中，我发现了 </span><code><span leaf="">org.tensorflow.lite.NativeInterpreterWrapper</span></code><span leaf=""> 类，这是 TFLite 在 Android 上的核心组件。</span></p><p><span leaf="">有了目标，接下来就可以用 </span><strong><span><span leaf="">Frida</span><sup><span leaf="">[2]</span></sup></span></strong><span leaf="">（一个强大的动态调试工具）进行跟踪。</span></p><figure><span leaf=""><img data-imgfileid="100004743" data-ratio="0.5111111111111111" data-type="png" data-w="1080" title="null" data-src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ou793P5sBR1JshicZqpMxYVWD2kECBdLjEspBkibuQjUaVVOzbiaoOGEEzw/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ou793P5sBR1JshicZqpMxYVWD2kECBdLjEspBkibuQjUaVVOzbiaoOGEEzw/640?wx_fmt=png&amp;from=appmsg"></span><figcaption></figcaption></figure><p><span leaf="">以下是使用的 Frida 命令：</span></p><pre><span hidden=""><svg xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" width="45px" height="13px" viewbox="0 0 450 130"><ellipse cx="50" cy="65" rx="50" ry="52" stroke="rgb(220,60,54)" stroke-width="2" fill="rgb(237,108,96)"></ellipse><ellipse cx="225" cy="65" rx="50" ry="52" stroke="rgb(218,151,33)" stroke-width="2" fill="rgb(247,193,81)"></ellipse><ellipse cx="400" cy="65" rx="50" ry="52" stroke="rgb(27,161,37)" stroke-width="2" fill="rgb(100,200,86)"></ellipse></svg></span><code><span leaf="">frida -U -n com.microsoft.seeingai -e </span><span><span leaf="">"</span><span leaf=""><br></span><span leaf="">Interceptor.attach(Module.findExportByName('libtensorflowlite_jni.so', '_ZN10tensorflowlite16NativeInterpreterWrapper13createModelWithBufferEPKvj'), {</span><span leaf=""><br></span><span leaf="">    onEnter: function (args) {</span><span leaf=""><br></span><span leaf="">        console.log('Model buffer address: ' + args[0]);</span><span leaf=""><br></span><span leaf="">        // 可以在这里将内存中的模型 dump 到本地</span><span leaf=""><br></span><span leaf="">    }</span><span leaf=""><br></span><span leaf="">});</span><span leaf=""><br></span><span leaf="">"</span></span></code></pre><p><span leaf="">通过这个脚本，我成功截获了应用加载 </span><code><span leaf="">currency</span></code><span leaf=""> 文件时的解密过程，并将解密后的 </span><code><span leaf="">.tflite</span></code><span leaf=""> 模型完整保存下来。</span></p><hr><h4><strong><span leaf="">第五步：验证模型</span></strong></h4><p><span leaf="">提取模型只是第一步，接下来要验证它的正确性。可以使用了 </span><strong><span><span leaf="">Netron</span><sup><span leaf="">[3]</span></sup></span></strong><span leaf="">，一个用于可视化神经网络模型的工具。</span></p><figure><span leaf=""><img data-imgfileid="100004745" data-ratio="0.6731481481481482" data-type="png" data-w="1080" title="null" data-src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ou7xV0vxIthiaC9NWcwCtibcljE058msO8gPgjOCZUgyAAuFjGF7uM8yhQ/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ou7xV0vxIthiaC9NWcwCtibcljE058msO8gPgjOCZUgyAAuFjGF7uM8yhQ/640?wx_fmt=png&amp;from=appmsg"></span><figcaption></figcaption></figure><p><span leaf="">如果 Netron 能正确打开这个模型文件，就说明提取成功。</span></p><pre><span hidden=""><svg xmlns="http://www.w3.org/2000/svg" version="1.1" x="0px" y="0px" width="45px" height="13px" viewbox="0 0 450 130"><ellipse cx="50" cy="65" rx="50" ry="52" stroke="rgb(220,60,54)" stroke-width="2" fill="rgb(237,108,96)"></ellipse><ellipse cx="225" cy="65" rx="50" ry="52" stroke="rgb(218,151,33)" stroke-width="2" fill="rgb(247,193,81)"></ellipse><ellipse cx="400" cy="65" rx="50" ry="52" stroke="rgb(27,161,37)" stroke-width="2" fill="rgb(100,200,86)"></ellipse></svg></span><code><span leaf="">netron currency.tflite</span></code></pre><p><span leaf="">结果显示，这个模型完整无误！它包含了所有的权重和偏置数据，完全可以直接用于重新训练或修改。</span></p><hr><h4><strong><span leaf="">更多可能性</span></strong></h4><p><span leaf="">这一过程不仅限于 Seeing AI，任何使用 TFLite 的应用理论上都可以通过类似方法提取模型。比如，还可以试着从 Adobe Scan 提取了它的文档识别模型，结果同样成功。</span></p><p><span leaf="">不过，这也引出一个问题：<span textstyle="">模型是应用的一部分，但模型的使用、修改乃至再分发可能涉及知识产权问题。提取模型后，务必遵守相关法律法规</span>。</span></p><hr><h4><strong><span leaf="">步骤总结</span></strong></h4><p><span leaf="">整个提取过程分为以下几步：</span></p><ol><li><section><span leaf="">1. </span><strong><span leaf="">解包 APK</span></strong><span leaf="">：找到目标文件；</span></section></li><li><section><span leaf="">2. </span><strong><span leaf="">逆向分析</span></strong><span leaf="">：搞清楚加密逻辑；</span></section></li><li><section><span leaf="">3. </span><strong><span leaf="">动态调试</span></strong><span leaf="">：用 Frida 截获解密后的模型；</span></section></li><li><section><span leaf="">4. </span><strong><span leaf="">验证模型</span></strong><span leaf="">：确保提取的数据是完整有效的。</span></section></li></ol><p><span leaf="">以下是流程图：</span></p><figure><span leaf=""><img data-imgfileid="100004746" data-ratio="2.466666666666667" data-type="png" data-w="360" title="null" data-src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ouGCP9A47OS5eKEhpTCNvP64icGHs0eLXPej8gwsic7QXJE5eGcVVOezOw/640?wx_fmt=png&amp;from=appmsg" src="https://mmbiz.qpic.cn/mmbiz_png/oXqG8ETvAelNEdJ5ROlTNGzfnAp3w3ouGCP9A47OS5eKEhpTCNvP64icGHs0eLXPej8gwsic7QXJE5eGcVVOezOw/640?wx_fmt=png&amp;from=appmsg"></span><figcaption></figcaption></figure><p><span leaf="">这一切并不复杂，但很考验耐心和细心。如果你对模型提取和逆向工程感兴趣，这可能是一个很好的实践案例。</span></p><hr><h4><strong><span leaf="">附注</span></strong></h4><p><span leaf="">虽然从技术角度来说，这是一项有趣的挑战，但在实践时要注意以下几点：</span></p><ol><li><section><span leaf="">1. 提取模型应遵守应用开发商的许可协议；</span></section></li><li><section><span leaf="">2. AI 模型作为一种数据资产，其归属权复杂，务必谨慎处理；</span></section></li><li><section><span leaf="">3. </span><strong><span leaf="">禁止用于非法用途</span></strong><span leaf="">。</span></section></li></ol><h4><span leaf="">引用链接</span></h4><p><code><span leaf="">[1]</span></code><span leaf=""> apktool: </span><i><span leaf="">https://apktool.org/</span></i><span leaf=""><br></span><code><span leaf="">[2]</span></code><span leaf=""> Frida: </span><i><span leaf="">https://frida.re/</span></i><span leaf=""><br></span><code><span leaf="">[3]</span></code><span leaf=""> Netron: </span><i><span leaf="">https://github.com/lutzroeder/netron</span></i><span leaf=""><br></span></p><p><span leaf=""><br></span></p><p><span leaf=""> </span></p><section><span leaf=""><br></span></section><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/76PRGFzwPPbCzAEfjsVLDw",target="_blank" rel="noopener noreferrer">原文链接</a>
